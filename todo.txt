Matthieu
--------

* [doc] Fix missing reference warnings. (See build/html/WARNINGS.log)
* use pycrt.coerce() where it makes sense. [PDS only; the CG/PGD ok.]
* use **kwargs to simplify signatures



Sepand
------

* Solver tests
  Remaining: opt/solver/pds.py
* Go over all code: refactor docstrings, type hints, etc.
  Remaining: opt/solver/pds.py
             compound/


   

Joan
----

* [opt] Implement LSQR LSMR
* Add SVG drawing of class diagrams in documentation
* create benchmark suite for all operators.

  We must track the runtime of operator methods across commits to identify performance regressions and fix them. A comprehensive benchmark suite is therefore required.

  Desired output: DataFrame with
  * row: class.method
  * column: commit name
  * value: execution time [s] (on sample data, identical throughout the commit history.)

  This data can then be plotted to visualize performance changes.


  Roadmap:
  - Numpy ufuncs -> Kaan
  - operators (Pycsou v1) -> core dev team
  - functionals (Pycsou v1 but unify loss and reg with 1 class and method "asloss") -> Kaan
  - Tutorials, examples and notebooks. -> Kaan
  - CI: pip/conda packaging (quick fix of pip lenghty install) + ReadTheDocs + Run tests in cloud (Infomaniak)
  - benchmarking suite (low priority)
  - Automatic hyperparameter tuning (hyperpriors) 
  - Uncertainty quantification (approximate credibility intervals)
  - Nonconvex/linear (APGD nonconvex + PDS nonlinear)
  - Pytorch interfacing (autodiff+jac+bwd eval) -> Alec
  - Stochastic solvers -> Alec
  - Second order solvers -> Kaan
  - LSQR/LSMR -> Kaan



 Daniele
----
- In test_math_lipschitz, if the functional has L=np.inf and if it can take the value np.inf (as it happens for indicator functionals), then nan=np.inf-np.inf < np.inf returns False and the test fails.